crypto.dummy_message_digests = false
crypto.message_digest        = SHA256
# plain, content, message, or content_and_message
crypto.digestion_strategy    = plain

# Default (cert_algo=default):
#   clients  = HMAC_SHA256
#   replies  = <clients>
#   replicas = HMAC_SHA256
# Insecure:
#   none,
#   SHA256, SHA1, MD5
#   DMAC_SHA256, DMAC_SHA1, DMAC_MD5
# MACs:
#   HMAC_SHA256, HMAC_SHA1, HMAC_MD5
# Signatures (<sigbase>_<keysize>_SHA256):
#	DSA_(512|1024|2048)
#   RSA_(512|1024|2048|3072)
#   ECDSA_(112|192|256|384|512)
# TSS:
#   TMAC_HMAC_SHA256
crypto.clients.cert_algo    = HMAC_SHA256
crypto.clients.dummy_certs  = false
crypto.clients.pre_digest   = false
crypto.replies.cert_algo    = default
crypto.replies.dummy_certs  = false
crypto.replies.pre_digest   = false
crypto.replicas.strong.cert_algo   = HMAC_SHA256
crypto.replicas.strong.dummy_certs = false
crypto.replicas.strong.pre_digest  = false
crypto.replicas.standard.cert_algo   = default
crypto.replicas.standard.dummy_certs = false
crypto.replicas.standard.pre_digest  = false

# java, cash, dummy, trinx
crypto.replicas.trusted  = java
#crypto.trinx.library     =
#crypto.trinx.enclave     =

agreement.protocol    = pbftx
agreement.replicas    = 4
agreement.quorum      = 3
agreement.weak_quorum = 2
agreement.commit_threshold      = 3
agreement.checkpoint_threshold  = 3
agreement.passive_checkpoints   = true

#-- regular, nodeprogress (which equals regular), apply (without ensuring exactly once semantics), send (without applying), create (without sending)
agreement.checkpoint_mode      = regular

# For replicas=4: 4, 3 (rotating), 2 (does not work when checkpoints are applied), woleader (leader does not send replies)
client.repliers              = 4
client.readonly_optimization = true
